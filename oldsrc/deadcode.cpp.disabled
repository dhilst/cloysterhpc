/* This is the graveyard where dead code resides for future reference */

#if 0
#if 0 /* Not ported yet to C++; broken */
    if (argc == 1) {
        /* Start up the graphical terminal interface */
        tuiStartup();
        exit(0);

#ifdef _DEBUG_
        tuiDebugInfo();
#endif

        tuiBeginInstall(&cluster);
        tuiExit();
    } else {
#endif
        optind = parseArguments(argc, argv);

        argc -= optind;
        argv += optind;
#if 0
    }
#endif
#endif

#if 0
    tuiStartup();

    /* popen(); with "FILE*" to "fd" converter test to newt
     * this is barely working, the function is not async, so popen() is not
     * streaming to the TUI interface.
     * newt Windows aren't good either, they can't automatic scroll like tail
     * on a console, so the implementation is just bad.
     */
    FILE* file = popen("ls && sleep 3 && ls -l", "r");
    char *out = NULL;
    size_t outlen = 0;

    int fd = fileno(file);

    int width, height;
    char *flowedText = NULL;

    newtComponent form;
    newtComponent text;
    struct newtExitStruct es;
    newtCenteredWindow(74, 20, "Garbage Title");
    form = newtForm(NULL, NULL, 0);
    newtFormWatchFd(form, fd, NEWT_FD_READ);
    //newtFormSetTimer(form, 1000);
    //text = newtLabel(0, 0, out);
    //newtFormAddComponents(form, text, NULL);

    
	char *textBuffer = '\0';
    //char *textBuffer = NULL;
    //textBuffer = (char *) malloc(sizeof(char));
    while (getline(&out, &outlen, file) >= 0) {
        textBuffer = (char *) realloc(textBuffer, strlen(textBuffer) + strlen(out) + 1);
        strcat(textBuffer, out);
        //text = newtLabel(0, 0, textBuffer);
        system("sleep 0.1");
        //newtFormAddComponents(form, text, NULL);
		//newtFormRun(form, &es);
		if (es.reason == NEWT_EXIT_FDREADY) {
            //text = newtTextboxReflowed(1, 1, textBuffer, 70, 5, 5, NEWT_TEXTBOX_WRAP | NEWT_FLAG_SCROLL);
            
  
            flowedText = newtReflowText(textBuffer, 60, 5, 5, &width, &height);

            text = newtTextbox(1, 1, width, height, NEWT_TEXTBOX_WRAP | NEWT_TEXTBOX_SCROLL);
            newtTextboxSetText(text, flowedText);

            newtFormAddComponents(form, text, NULL);
			//printf("%s", textBuffer);
		} else if (es.reason == NEWT_EXIT_COMPONENT) {
            printf("WHAT\n");
		}
        newtFormRun(form, &es);
	}
    free(textBuffer);
    free(out);
	newtFormDestroy(form);

    tuiExit();
#endif

#if 0
void newtPipe(char *title, FILE* fd) {
    newtComponent form, text;
    char *out = NULL;
    size_t outlen = 0;

    newtCenteredWindow(74, 20, title);
    form = newtForm(NULL, NULL, 0);
    //newtFormWatchFd(form, fd, NEWT_FD_READ);
    //newtFormSetTimer(form, 100);

    fseek(fd, 0, SEEK_END);
    long fsize = ftell(fd);
    fseek(fd, 0, SEEK_SET);  /* same as rewind(f); */

    char *string = malloc(fsize + 1);
    fread(string, 1, fsize, fd);

    string[fsize] = 0;

    text = newtLabel(0, 0, string);
    newtFormAddComponents(form, text, NULL);
    newtFormWatchFd(form, (long) fd, NEWT_FD_READ);

    newtRunForm(form);

/*
    while (getline(&out, &outlen, fd) >= 0) {
        text = newtLabel(0, 0, out);
        newtFormAddComponents(form, text, NULL);
        newtFormWatchFd(form, (long) fd, NEWT_FD_READ);
        newtRunForm(form);
    }
*/
/*
    text = newtLabel(0, 0, message);
    newtFormWatchFd(form, fd, NEWT_FD_READ);
	newtFormSetTimer(form, 100);
    newtFormAddComponents(form, text, NULL);

    newtRunForm(form);
*/
	newtFormDestroy(form);


}
#endif

#if 0
    /* popen test with newt*/
    tuiStartup();

    FILE* file = popen("ls -l", "r"); // You should add error checking here.

    newtPipe(MSG_TITLE_HELP, file);

#if 0
    char *out = NULL;
    size_t outlen = 0;
    while (getline(&out, &outlen, file) >= 0)
    {
        //va_list args;
        //newtvwindow(MSG_TITLE_HELP, "PENE", out, args);
        newtPipe(MSG_TITLE_HELP, out, file);
        //system("sleep 0.1");
        //printf("%s", out);
        //printf("oi\n");
    }
#endif
    pclose(file);
//    free(out);

    tuiExit();
#endif

/* MVP Graveyard */

#if 0
class Presenter : public viewSubscriber {
private:
    Cluster* m_cluster{};
    TerminalUI* m_terminalui{};

    void startView ();
    std::string requestTimezone ();
    std::string requestLocale ();
    std::vector<std::string> requestHostname ();
    std::string requestNetworkInterface ();
    std::vector<std::string> requestNetworkAddress ();
}
#endif

#if 0
#if 0
    /* TODO: Better names for TerminalUI; newt instead? */
    View* view = new TerminalUI();

    auto* locale = new PresenterLocaleSelection(*view);
    locale->write(cluster);
    delete locale;

    delete view;

//    startView();
//    terminalui.~TerminalUI();
}
#endif

void Presenter::startView() {
    /* Timezone */
//    headnode->timezone = requestTimezone();
//    cluster->timezone = headnode->timezone;
//
//    /* Locale */
//    headnode->locale = requestLocale();
//    cluster->locale = headnode->locale;
//
//    /* Hostname and domainname*/
//    std::vector<std::string> fields = requestHostname();
//    headnode->hostname = fields[0];
//    headnode->domainname = fields[1];
//    headnode->fqdn = headnode->hostname + "." + headnode->domainname;

    /* External Network Interface */
    //Connection connection;
//    Network network;
//    network.setProfile(Network::Profile::External);
//    network.setType(Network::Type::Ethernet);
//    network.setInterfacename(requestNetworkInterface());
    //connection.setInterfaceName();
    //headnode->externalConnection.push_back(connection);
//    headnode->externalNetwork.push_back(network);

    /* Get IP addresses */
//    std::vector<std::string> fields = requestNetworkAddress();
//    m_headnode->external[0].setIPAddress(fields[0], fields[1]);

}

std::string Presenter::requestTimezone () {
    /* TODO: Fetch timezones from OS and remove placeholder text */
     const std::vector<std::string> timezones = {
         "America/Sao_Paulo",
         "UTC",
         "Gadific Mean Bolsotime",
         "Chronus",
         "Two blocks ahead"
     };

    return m_terminalui->timezoneSelection(timezones);
}

std::string Presenter::requestLocale () {
    const std::vector<std::string> locales = {
        "en.US_UTF-8",
        "pt.BR_UTF-8",
        "C"
    };

    return m_terminalui->localeSelection(locales);
}

/* This method should be renamed or ask just for hostname */
std::vector<std::string> Presenter::requestHostname () {
    const std::vector<std::string> entries = {
        "Hostname",
        "Domain Name"
    };

    return m_terminalui->networkHostnameSelection(entries);
}

/* TODO: Data model is strange, needs fixing. requestNetworkInterface() should
 * be more generic than it's now, not being tied for internal or external
 * interfaces
 */
std::string Presenter::requestNetworkInterface () {
    const std::vector<std::string> netInterfaces = {
        "eth0",
        "eth1",
        "enp4s0f0",
        "lo",
        "ib0",
    };

    return m_terminalui->networkInterfaceSelection(netInterfaces);
}

std::vector<std::string> Presenter::requestNetworkAddress () {
    const std::vector<std::string> networkAddresses = {
        "Headnode IP",
        "Management Network"
    };

    return m_terminalui->networkAddress(networkAddresses);
}

#endif

